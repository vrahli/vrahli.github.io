<!DOCTYPE HTML>
<!--
	Introspect by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<title>Vincent Rahli - Projects</title>

		<meta charset="utf-8" />

		<meta name="keywords"    content="vincent rahli, Birmingham, SnT, CritiX, PRL group, Nuprl, Cornell"/>
		<meta name="Description" content="Vincent Rahli's projects"/>
		<meta name="Author"      content="Vincent Rahli"/>
		<meta name="viewport"    content="width=device-width, initial-scale=1, user-scalable=no" />

		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body>

		<!-- Header -->
			<header id="header">
				<div class="inner">
					<a href="index.html" class="logo">Vincent Rahli</a>
					<nav id="nav">
						<a href="index.html">Home</a>
						<a href="projects.html">Projects</a>
						<a href="papers.html">Papers</a>
						<a href="talks.html">Talks</a>
						<a href="code.html">Code</a>
						<a href="lectures.html">Lectures</a>
						<a href="contact.html">Contact</a>
						<a href="links.html">Links</a>
					</nav>
				</div>
			</header>
			<a href="#menu" class="navPanelToggle"><span class="fa fa-bars"></span></a>


		<!-- Main -->
			<section id="main" >
				<div class="inner">

					<header class="major special">
						<h1>Funded Projects</h1>
					</header>

                                        <h3><span class="conference">Design and Verification of Time-Critical Byzantine Fault-Tolerant Systems</span></h3>
					  <p>
This project comes with <u>funding</u> for the following positions (don't hesitate to contact me for more information):
<ul class="np">
    <li>an up to 3 years fully-funded <u>postdoctoral</u> position</li>
    <li>a fully-funded <u>PhD</u> position</li>
</ul>

The main goals of this project are to (1) develop generic, yet
efficient Byzantine Fault Tolerance (BFT) defense
mechanisms that can be applied to a wide range of infrastructures, and
(2) provide strong correctness guarantees.

<br/>

<u>Design of BFT protocols.</u> We propose to develop novel BFT techniques
that are less costly (less replicas and less exchanged messages) than
state-of-the-art solutions by relying on trusted components (e.g.,
secure hardware components such as Intel SGX), and to apply these
techniques to develop more efficient and reliable blockchain systems.
Moreover, we also propose to developed techniques to turn
state-of-the-art BFT protocols into protocols that achieve timeliness
guarantees, allowing their integration in real-time applications.

<br/>

<u>Formal verification of BFT protocols.</u> One way to provide strong
correctness guarantees is to use formal verification methods, such as
theorem provers to automatically or interactively prove that a piece
of software or hardware behaves as intended. Many theorem provers have
been developed and improved over the years allowing to do just that,
such as Agda, Coq, Isabelle, etc. We propose to make use of the
highly expressive Coq or Agda provers to ensure the correctness of these
protocols. More precisely, we propose to develop within those provers, support
to implement BFT protocols, models to capture the environments in
which those protocols execute, as well as proof techniques to
guarantee their correctness.
					  </p>


					<header class="major special">
						<h1>Other Recent Projects</h1>
					</header>

					</br>


					<button class="collapsible"><h3><span class="conference">Asphalion</span></h3></button>
					<div class="content">
					  <p>
					    Asphalion is an extension of Velisarios, also implemented in Coq, that
					    supports the verification of hybrid fault-tolerant systems, i.e.,
					    systems that combine components that can fail arbitrarily and
					    components that can only crash on failure.
					    To reason about such systems, Asphalion provides a sound knowledge
					    sequent calculus that features both non-trusted and trusted
					    knowledge operators.
					    Using Asphalion we have verified one of the main safety
					    property of the MinBFT landmark protocol.
					    This is joint work with
					    <a href="http://wwwen.uni.lu/snt/people/ivana_vukotic">Ivana Vukotic</a>
					    and <a href="https://wwwen.uni.lu/snt/people/paulo_esteves_verissimo">Paulo Verissimo</a>
					  </p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">Velisarios</span></h3></button>
					<div class="content">
					<p>
					  Velisarios is an extension of EventML, implemented in Coq, that
					  supports the verification of Byzantine fault-tolerant systems, and
					  reasoning about  distributed epistemic knowledge.
					  Using Velisarios we have verified the standard agreement safety
					  property of the PBFT
					  landmark protocol.
					  Check
					  out <a href="https://github.com/vrahli/Velisarios">our implementation</a> for details.
					  In the future, we want to support proving properties such as
					  liveness and timeliness, and we want to connect Velisarios with the Verified
					  Software Toolchain (VST) in order to verify the correctness of
					  programs written in C.
					This is joint work with
					<a href="http://wwwen.uni.lu/snt/people/ivana_vukotic">Ivana Vukotic</a>,
					    <a href="http://wwwen.uni.lu/snt/people/marcus_voelp">Marcus Volp</a>,
					    and <a href="https://wwwen.uni.lu/snt/people/paulo_esteves_verissimo">Paulo Verissimo</a>
					</p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">Certified theorem proving (Nuprl in Coq)</span></h3></button>
					<div class="content">

					<p>Allen's Partial Equivalence Relation (PER) semantics provides a
					semantics for Nuprl's type theory that allows one to prove that
					Nuprl's inference rules are valid, and therefore that Nuprl is
					consistent.  Until
					our <a href="articles/semantics-ITP-2014-04-18.pdf">ITP
					2014 paper</a>, these proofs
					were done by hand.  In
					order to formally prove that these rules are correct (and therefore
					that Nuprl is consistent), we have implemented this PER semantics
					using the Coq proof assistant.  This implementation (1) provides a
					bridge between Nuprl and Coq, and (2) is the basis for developing
					certified versions of
					  Nuprl.
					This is joint work with <a href="http://www.cs.cornell.edu/~aa755/">Abhishek Anand</a>
					and <a href="http://www.nuprl.org/html/PeopleErsatz/markb.html">Mark Bickford</a>.
					</p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">Certified theorem proving (KeYmaera X in Coq)</span></h3></button>
					<div class="content">

					<p>KeYmaera X is a theorem prover for cyber-physical systems (modeled
					as hybrid systems) that implements a logic called Differential
					Dynamic Logic (dL for short).  KeYmaera X has a small core thanks a
					uniform substitution based proof calculus.  <a class="apdf" href="articles/verified-dL-CPP-preprint-2016-11-29.pdf">We have implemented and
					verified this core in Coq.</a>
					Check
					out <a href="https://github.com/LS-Lab/Coq-dL">our
					implementation</a> for details.  This was joint work
					with <a href="http://www.cs.cmu.edu/~bbohrer/">Brandon
					  Bohrer</a> and <a href="http://symbolaris.com/">Andre
					  Platzer</a> from CMU, who have implemented and verified
					KeYmaera's core in <a href="https://github.com/LS-Lab/Isabelle-dL">Isabelle</a>.
					</p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">Intuitionistic and Nominal Type Theory</span></h3></button>
					<div class="content">

					<p>
					  Using our formalization of Nuprl in Coq, we are turning Nuprl into an
					  intuitionistic type theory, i.e., we have proved that some
					  versions of
					  Brouwer's <a href="articles/continuity-final.pdf">continuity</a>
					  and <a href="articles/bar-induction-lics-short.pdf">bar induction</a> principles are valid
					  w.r.t. Nuprl's PER semantics.  In order to prove the validity of such
					  continuity principles we have turned Nuprl into a nominal type theory.
					  It remains open whether
					  stronger continuity and bar
					  induction rules are also valid.
					  Moreover, we have also implemented a version of Brouwer's concept of
					  <a class="apdf" href="articles/FCS-short.pdf">choice sequences</a> on top of
					  Nuprl's underlying digital library of facts
					  and definitions.  In addition, the library can now also contain
					  sequences of choices that can be filled over time.  We validated
					  standard axioms about choice sequences by turning Nuprl's semantics
					  into a Beth model.
					This is joint work with <a href="https://www.cs.cornell.edu/~lironcohen/">Liron Cohen</a>,
					<a href="http://www.nuprl.org/html/PeopleErsatz/markb.html">Mark Bickford</a>,
					    and <a href="http://www.cs.cornell.edu/home/rc/">Robert L. Constable</a>.
					</p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">EventML</span></h3></button>
					<div class="content">

					<p><a class="apdf" href="articles/two-thirds-consensus-journal.pdf">EventML</a> is a ML-like constructive
					specification language that implements a paradigm for verified
					programming.  It gives precedence to the programming task, and also
					allows programmers to cooperate with a proof assistant in order to
					structure arguments of correctness.
					It is designed specifically to cooperate with the Nuprl proof
					assistant in order to develop correct-by-construction asynchronous
					  protocols.
					This is joint work with
					<a href="http://www.nuprl.org/html/PeopleErsatz/markb.html">Mark Bickford</a>
					    and <a href="http://www.cs.cornell.edu/home/rc/">Robert L. Constable</a>.
					</p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">Synthesis and verification of distributed protocols</span></h3></button>
					<div class="content">

					<p>Using EventML, we have specified, synthesized, and
					verified safety properties of the Multi-Paxos protocol.
					To do so,
					we have automated some patterns of reasoning;
					and to get efficient code, we have built a process
					optimizer in Nuprl.
					We are reusing this methodology to develop other
					provably correct protocols, striving towards more resilient and
					trustworthy systems.
					One of our current goal is to verify Byzantine fault tolerant
					protocols written in C using,
					  among other things, the
					  <a href="http://vst.cs.princeton.edu/">Verified Software Toolchain (VST)</a>.
					  This is joint work with
					  <a href="http://www.nuprl.org/html/PeopleErsatz/markb.html">Mark Bickford</a>,
					  <a href="http://www.cs.cornell.edu/home/rc/">Robert L. Constable</a>,
					  <a href="http://wwwen.uni.lu/snt/people/ivana_vukotic">Ivana Vukotic</a>,
					  <a href="http://wwwen.uni.lu/snt/people/marcus_voelp">Marcus Volp</a>,
					  and <a href="https://wwwen.uni.lu/snt/people/paulo_esteves_verissimo">Paulo Verissimo</a>
					</p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">Skalpel</span></h3></button>
					<div class="content">

					<p>Programming languages
					such as SML
					have sophisticated, flexible and
					safe type systems.
					Unfortunately, the type error messages for incorrect programs are confusing.
					Skalpel implements a promising approach to making type errors easier to understand and
					fix called type error slicing, in which slices (program points)
					containing all and only the information needed by the programmer to
					understand and fix a type error are identified and
					exhibited.
					Check out <a href="http://www.macs.hw.ac.uk/ultra/skalpel/">the
					  web page of our project</a>,
					from which you can download
					packages for Debian and Red-Hat-based systems as well as
					  a web demo.</p>
					</div>
					</br></br>


					</br>


					<header>
						<h1>Past Projects</h1>
					</header>

					</br>


					<button class="collapsible"><h3><span class="conference">Semantics of expansion</span></h3></button>
					<div class="content">

					<p>Intersection types
					introduce type polymorphism in a finitary way.  Expansion was
					introduced to recover the principal typing property
					in such systems.
					The study of realisability semantics for such systems
					with expansion
					might help casting some light on the expansion mechanism.</p>
					</div>
					</br></br>


					<button class="collapsible"><h3><span class="conference">Reducibility proofs</span></h3></button>
					<div class="content">

					<p>Reducibility is a
					  method based on realisability semantics
					  where the idea is to interpret types by sets of &lambda;-terms
					  closed under some properties.
					  This method
					  seems promising in generalising diverse properties' proofs of the
					  (typed or untyped) &lambda;-calculus.</p>
					</div>
					</br></br>
				</div>
			</section>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script src="assets/js/collapsible.js"></script>

	</body>
</html>
